
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================


`define clkdiv_50m_to_115k 217


module DE0_NANO_UART_Send(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,

	//////////// 2x13 GPIO Header //////////
	GPIO_2,
	GPIO_2_IN 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// 2x13 GPIO Header //////////
inout 		    [12:0]		GPIO_2;
input 		     [2:0]		GPIO_2_IN;




//=======================================================
//  REG/WIRE declarations
//=======================================================
reg UART_TX;

assign GPIO_2[1] = UART_TX;


// Some register and wire declarations
reg [3:0] transmit_state;
reg [7:0] transmit_data;
reg 	     key1_reg;
wire      key1_edge_detect;

// Reset
wire 					reset;
assign reset = ~KEY[0];

// Tie UART_GND low
assign UART_GND = 0;

//UART transmit at 115200 baud from 50MHz clock
reg [9:0] 					clock_divider_counter;
reg 						uart_clock;


// Clock counter
/*
 How to generate a 115.2kHz clock down below?
 */   
always @(posedge CLOCK_50) 
  begin
if (reset == 1'b1)
  clock_divider_counter <= 0;
else if (clock_divider_counter > `clkdiv_50m_to_115k)
  clock_divider_counter <= 0;
else
  // Otherwise increment the counter
  clock_divider_counter <= clock_divider_counter + 1;
  end

// Generate a clock (toggle this register)
always @(posedge CLOCK_50) 
  begin
if (reset == 1'b1)
  uart_clock <= 0;
else if (clock_divider_counter == `clkdiv_50m_to_115k)
  uart_clock <= ~uart_clock;
  end

always @(posedge uart_clock or posedge reset) begin
if (reset) begin
	  // Reset to the "IDLE" state
	  transmit_state <= 0;

	  // The UART line is set to '1' when idle, or reset
	  UART_TX <= 1;

	  // Data we'll transmit - start at ASCII '0'
	  transmit_data <= 8'h30;
	  
end
else begin
	  
	case (transmit_state)
		0: begin
			if( key1_edge_detect ) begin
				transmit_state <= 1;
			end else begin
				transmit_state <= 0;
			end
		end
		1: begin
			UART_TX <= 0;
			transmit_state <= 2;
		end
		2,3,4,5,6,7,8,9: begin
			UART_TX <= transmit_data[transmit_state-2];
			transmit_state <= transmit_state+1;
		end
		10: begin
			UART_TX <= 1;
			transmit_data <= transmit_data + 1;
			transmit_state <= 0;
		end
		default:
			transmit_state <= 0;
	endcase
end
end

always @(posedge uart_clock)
  key1_reg <= KEY[1];

assign key1_edge_detect = ~KEY[1] & key1_reg;

assign LED = transmit_data;

endmodule
